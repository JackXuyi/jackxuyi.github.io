<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奔跑的蜗牛</title>
  
  <subtitle>奔跑的蜗牛</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-07T06:46:15.309Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>奔跑的蜗牛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react中的jsx语法</title>
    <link href="http://yoursite.com/2021/06/06/react%E4%B8%AD%E7%9A%84jsx%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2021/06/06/react中的jsx语法/</id>
    <published>2021-06-06T14:30:07.000Z</published>
    <updated>2021-06-07T06:46:15.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a><code>JSX</code></h2><p><code>JSX</code> 是一种嵌入式的类似 <code>XML</code> 的语法。 它可以被转换成合法的 <code>JavaScript</code>，尽管转换的语义是依据不同的实现而定的。 <code>JSX</code> 因 <code>React</code> 框架而流行，但也存在其它的实现。</p><h3 id="React-中的-JSX"><a href="#React-中的-JSX" class="headerlink" title="React 中的 JSX"></a><code>React</code> 中的 <code>JSX</code></h3><p><code>JSX</code> 为我们提供了创建 <code>React</code> 元素方法（<code>React.createElement(component, props, ...children)</code>）的语法糖（<code>syntactic sugar</code>）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;div&gt;Hello, world!&lt;/div&gt;</span><br><span class="line"><span class="comment">// 编译后会被转化为</span></span><br><span class="line"><span class="keyword">var</span> element = React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="string">'Hello, world!'</span>) <span class="comment">// 返回一个对象</span></span><br></pre></td></tr></table></figure><h4 id="JSX-代表-JS-对象"><a href="#JSX-代表-JS-对象" class="headerlink" title="JSX 代表 JS 对象"></a><code>JSX</code> 代表 <code>JS</code> 对象</h4><p><code>JSX</code> 本身也是一个表达式，在编译后，<code>JSX</code> 表达式会变成普通的 <code>JavaScript</code> 对象。执行 <code>React.createElement</code> 之后最终会执行一下代码生成一个普通的 <code>JavaScript</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可以看出，执行 <code>React.createElement</code> 时只支持表达式，同时可以在以下情况中使用</p><ul><li>可以在 <code>if</code> 语句或 <code>for</code> 循环中使用 <code>JSX</code></li><li>可以将它赋值给变量</li><li>可以将它作为参数接收</li><li>可以在函数中返回 <code>JSX</code>。</li></ul><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>在 <code>JavaScript</code> 中，表达式就是一个短语，<code>Javascript</code> 解释器会将其计算出一个结果，常量就是最简单的一类表达式。常用的表达式有：</p><ul><li>变量名</li><li>函数定义表达式</li><li>属性访问表达式</li><li>函数调用表达式</li><li>算数表达式</li><li>关系表达式</li><li>逻辑表达式</li></ul><p>注意: <code>if</code> 语句以及 <code>for</code> 循环不是 <code>JavaScript</code> 表达式</p><h4 id="JSX-可自动防范注入攻击"><a href="#JSX-可自动防范注入攻击" class="headerlink" title="JSX 可自动防范注入攻击"></a><code>JSX</code> 可自动防范注入攻击</h4><p>在默认情况下，React DOM 会将所有嵌入 JSX 的值进行编码，利用 <code>createTextNode</code> 进行 <code>HTML</code> 转义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextNode</span>(<span class="params">text, rootContainerElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(</span><br><span class="line">    text</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若希望直接将字符串不经转义编码直接插入到 <code>HTML</code> 文档流，可以使用 <code>dangerouslySetInnerHTML</code> 属性，这是一个 <code>React</code> 版的 <code>innerHTML</code>，该属性接收一个 <code>key</code> 为 <code>__html</code> 的对象</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><code>JSX</code> 会自动删除一行中开头和结尾处的空白符；</li><li><code>JSX</code> 会自动删除空行；</li><li><code>JSX</code> 会删除紧邻标签的换行；</li><li><code>JSX</code> 会删除字符串中的换行；</li><li>字符串中的换行会被转换成一个空格。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>允许使用熟悉的语法来定义 <code>HTML</code> 元素树</li><li>提供了更加语义化且易懂的标签</li><li>程序结构更容易被直观化</li><li>抽象了 <code>React Element</code> 的创建过程</li><li>可以随时掌控 <code>HTML</code> 标签以及生成这些标签的代码</li><li>原生 <code>Javascript</code></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/jsx.html" target="_blank" rel="noopener">JSX</a></li><li><a href="https://www.cnblogs.com/candlia/p/11920070.html" target="_blank" rel="noopener">JSX 语法使用详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSX&quot;&gt;&lt;a href=&quot;#JSX&quot; class=&quot;headerlink&quot; title=&quot;JSX&quot;&gt;&lt;/a&gt;&lt;code&gt;JSX&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JSX&lt;/code&gt; 是一种嵌入式的类似 &lt;code&gt;XML&lt;/code&gt; 的语法。 它可以被
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react中的异步实现</title>
    <link href="http://yoursite.com/2021/05/30/react%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2021/05/30/react中的异步实现/</id>
    <published>2021-05-30T13:37:54.000Z</published>
    <updated>2021-05-30T06:44:31.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>由于 <code>JS</code> 是单线程非阻塞的，所有的任务都需要在这个线程中来处理。当需要执行异步任务时主线程会先挂起这个任务，当异步任务执行完毕之后主线程会根据规则执行回调。当任务处理完毕之后， <code>JS</code> 会将这个事件加入队列中，这个队列即被称为事件队列。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul><li>进程： <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li><li>线程： 进程中的更小单位，描述了执行一段指令所需的时间。</li></ul><p>在浏览器中，当你打开一个 <code>Tab</code> 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、<code>JS</code> 引擎线程、<code>HTTP</code> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><p>在 <code>JS</code> 运行的时候会阻止 <code>UI</code> 渲染，这是因为 <code>JS</code> 可以修改 <code>DOM</code>，如果在 <code>JS</code> 执行的时候 <code>UI</code> 线程还在工作，就可能导致不能安全的渲染 <code>UI</code>。这其实也是一个单线程的好处，得益于 <code>JS</code> 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。</p><p>对于锁的问题，形象的来说就是当我读取一个数字 <code>15</code> 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>所有的 <code>JS</code> 代码在运行时都是在执行上下文中进行的。<code>JS</code> 中有三种执行上下文：</p><ul><li>全局执行上下文，默认的，浏览器中是 <code>window</code> 对象，<code>nodejs</code> 中是 <code>global</code>，并且 <code>this</code> 在非严格模式下指向它们。</li><li>函数执行上下文，<code>JS</code> 的函数每当被调用时会创建一个上下文。</li><li><code>Eval</code> 执行上下文，<code>eval</code> 函数会产生自己的上下文。</li></ul><p>栈是一种数据结构，具有先进后出的原则。<code>JS</code> 中的执行栈就具有这样的结构，当引擎第一次遇到 <code>JS</code> 代码时，会产生一个全局执行上下文并压入执行栈，每遇到一个函数调用，就会往栈中压入一个新的上下文。引擎执行栈顶的函数，执行完毕，弹出当前执行上下文。</p><h4 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h4><p>异步任务被分为两种类型，微任务和宏任务</p><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><ul><li><code>Promise.then</code></li><li><code>MutationObserver</code></li><li><code>process.nextTick</code></li></ul><h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><ul><li><code>script</code>(整体代码)</li><li><code>setTimout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>MessageChannel</code></li><li><code>requestAnimationFrame</code></li><li><code>postMessage</code></li><li><code>I/O</code></li><li><code>UI</code> 交互事件</li></ul><h4 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h4><p><code>Event Loop</code>(事件循环)中，每一次循环称为 <code>tick</code>, 每一次 <code>tick</code> 的任务如下：</p><ol><li>执行栈选择最先进入队列的宏任务(通常是 <code>script</code> 整体代码)，如果有则执行</li><li>检查是否存在 <code>Microtask</code>，如果存在则不停的执行，直至清空 <code>microtask</code> 队列</li><li>更新 <code>render</code>(每一次事件循环，浏览器都可能会去更新渲染)</li><li>重复以上步骤</li></ol><p>宏任务 &gt; 所有微任务 &gt; 宏任务，如下图所示：</p><p><img src="/images/js/eventLoop.jpg" alt="新建工程"></p><ol><li>将所有任务看成两个队列：执行队列与事件队列。</li><li>执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。</li><li>当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务</li></ol><h3 id="react-中的异步实现"><a href="#react-中的异步实现" class="headerlink" title="react 中的异步实现"></a>react 中的异步实现</h3><p><code>react</code> 中的异步是通过宏任务来实现的，优先使用 <code>setImmediate</code> ，然后使用 <code>MessageChannel</code>，若都不支持则使用 <code>setTimeout</code> 实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedulePerformWorkUntilDeadline</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> localSetImmediate === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="comment">// Node.js and old IE.</span></span><br><span class="line">  <span class="comment">// There's a few reasons for why we prefer setImmediate.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.</span></span><br><span class="line">  <span class="comment">// (Even though this is a DOM fork of the Scheduler, you could get here</span></span><br><span class="line">  <span class="comment">// with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)</span></span><br><span class="line">  <span class="comment">// https://github.com/facebook/react/issues/20756</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// But also, it runs earlier which is the semantic we want.</span></span><br><span class="line">  <span class="comment">// If other browsers ever implement it, it's better to use it.</span></span><br><span class="line">  <span class="comment">// Although both of these would be inferior to native scheduling.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetImmediate(performWorkUntilDeadline)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// DOM and Worker environments.</span></span><br><span class="line">  <span class="comment">// We prefer MessageChannel because of the 4ms setTimeout clamping.</span></span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = performWorkUntilDeadline</span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// We should only fallback here in non-browser environments.</span></span><br><span class="line">  schedulePerformWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    localSetTimeout(performWorkUntilDeadline, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断是否存在 <code>setImmediate</code>，如果存在则使用 <code>setImmediate</code>，不存在下一步</li><li>判断是否支持 <code>MessageChannel</code>，如果支持则创建一个消息通道，通过消息通道实现宏任务，否则进行下一步</li><li>回落到 <code>setTimeout</code> 实现异步</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/59784952" target="_blank" rel="noopener">深入理解 JavaScript 执行上下文和执行栈</a></li><li><a href="https://segmentfault.com/a/1190000015317434" target="_blank" rel="noopener">Js 的事件循环(Event Loop)机制以及实例讲解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener">MessageChannel</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事件循环&quot;&gt;&lt;a href=&quot;#事件循环&quot; class=&quot;headerlink&quot; title=&quot;事件循环&quot;&gt;&lt;/a&gt;事件循环&lt;/h3&gt;&lt;p&gt;由于 &lt;code&gt;JS&lt;/code&gt; 是单线程非阻塞的，所有的任务都需要在这个线程中来处理。当需要执行异步任务时主线程会先挂
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端框架</title>
    <link href="http://yoursite.com/2021/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2021/04/18/前端框架/</id>
    <published>2021-04-17T22:48:43.000Z</published>
    <updated>2021-05-30T06:44:31.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM-操作时代"><a href="#DOM-操作时代" class="headerlink" title="DOM 操作时代"></a>DOM 操作时代</h3><p>代表库 <a href="https://jquery.com/" target="_blank" rel="noopener"><code>jQuery</code></a> 和 <a href="https://zeptojs.com/" target="_blank" rel="noopener"><code>zepto</code></a></p><ul><li>简化选择器</li><li>简化 <code>DOM</code> 操作</li><li>简化 <code>AJAX</code> 操作</li><li>统一事件绑定</li><li>兼容性实现</li><li>延时对象（<code>$.Deferred</code>）</li></ul><h4 id="DOM-操作的一般流程"><a href="#DOM-操作的一般流程" class="headerlink" title="DOM 操作的一般流程"></a>DOM 操作的一般流程</h4><ol><li><code>DOM</code> 加载</li><li><code>js</code> 脚本加载</li><li><code>js</code>脚本执行，发送异步请求获取数据</li><li>操作 <code>DOM</code> 进行数据渲染</li><li>对 <code>DOM</code> 节点进行事件绑定</li></ol><p><img src="/images/domprocess.png" alt="DOM 操作流程"></p><h3 id="MV-交互模式"><a href="#MV-交互模式" class="headerlink" title="MV* 交互模式"></a>MV* 交互模式</h3><h4 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h4><p>将 <code>DOM</code> 交互部分的内容分为数据模型、视图和事件控制三部分</p><ul><li><code>Model</code>：存放请求的数据结果和数据对象</li><li><code>View</code>: 页面 <code>DOM</code> 的更新与修改</li><li><code>Controller</code>: 根据前端路由条件调用不同的 <code>Model</code> 和 <code>View</code>渲染不同的数据内容</li></ul><p>用户的操作直接通过 <code>Controller</code> 控制</p><h4 id="MVP-模式"><a href="#MVP-模式" class="headerlink" title="MVP 模式"></a>MVP 模式</h4><p><code>Model-View-Presenter</code>，将 <code>DOM</code> 交互部分的内容分为数据模型、视图和 <code>Presenter</code> 三部分</p><ul><li><code>Model</code>：存放请求的数据结果和数据对象（仅提供数据）</li><li><code>View</code>: 页面 <code>DOM</code> 的更新与修改（仅提供视图模板）</li><li><code>Presenter</code>: 根据前端路由条件调用不同的 <code>Model</code> 和 <code>View</code>渲染不同的数据内容（主要的逻辑处理）</li></ul><p><code>Presenter</code> 与 <code>View</code> 的绑定是双向的，<code>Presenter</code> 的改变会改变 <code>View</code>，<code>View</code> 的改变也会触发 <code>Presenter</code>，所有的逻辑调用数据和渲染视图 <code>View</code> 模板都在 <code>Presenter</code> 中完成，同时用户在 <code>View</code> 层操作的改变反馈到 <code>Presenter</code> 改变 <code>Model</code>并渲染新的 <code>View</code> 视图。</p><ul><li>优点：只需关注 <code>Presenter</code> 的逻辑</li><li>缺点：内容较重</li></ul><h4 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h4><p>自动化的 <code>MVP</code> 框架，用 <code>ViewModel</code> 代替 <code>Presenter</code>，<code>Model</code> 的调用和 <code>View</code> 由 <code>ViewModel</code> 自动触发完成<br>用户操作时， <code>ViewModel</code> 捕获数据变化，将变化反应到 <code>View</code> 上。 <code>ViewModel</code> 的数据操作最终在页面上以 <code>Directive</code> 的形式体现，通过对 <code>Directive</code> 的识别来渲染数据或绑定事件。</p><h5 id="通用基本设计"><a href="#通用基本设计" class="headerlink" title="通用基本设计"></a>通用基本设计</h5><ul><li><code>Directive</code>: 指令，即自定义执行函数</li><li><code>Filter</code>: 过滤器，对传入的初始数据信进行处理，然后把处理结果交给下一步（<code>Directive</code> 或 <code>Filter</code>）。</li><li>表达式：控制页面内容按照具体条件展示</li><li><code>ViewModel</code>: 实现传入的 <code>Model</code> 数据在内存中存放，也提供一些基本的读取或修改数据的 <code>API</code></li><li>数据变更检查： 即数据变化自动触发其它操作，通过手动触发、脏检测、对象劫持、<code>Proxy</code> 等</li></ul><h6 id="数据变更检查"><a href="#数据变更检查" class="headerlink" title="数据变更检查"></a>数据变更检查</h6><ul><li>手动触发: 通过在数据对象上定义 <code>get</code> 和 <code>set</code> 方法，调用时手动触发 <code>get</code> 和 <code>set</code> 来获取和修改数据，改变后主动触发 <code>get</code> 和 <code>set</code> 中 <code>View</code> 层的重新渲染功能</li><li>脏检测: 在 <code>ViewModel</code> 对象的某个属性值发生变化时找到与这个属性值相关的所有元素，然后比较数据变化，如果有变化则进行 <code>Directive</code> 指令调用，对这个元素进行重新扫描渲染</li><li>前端数据对象劫持： 使用 <code>Object.defineProperty</code> 和 <code>Object.defineProperties</code> 对 <code>ViewModel</code> 数据对象进行属性 <code>get</code> 和 <code>set</code> 的监听，当有数据读取和赋值时则扫描节点元素，运行指定对应节点的 <code>Directive</code> 指令。</li><li><code>ES6 Proxy</code>:类似与 <code>Object.defineProperty</code> 和 <code>Object.defineProperties</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DOM-操作时代&quot;&gt;&lt;a href=&quot;#DOM-操作时代&quot; class=&quot;headerlink&quot; title=&quot;DOM 操作时代&quot;&gt;&lt;/a&gt;DOM 操作时代&lt;/h3&gt;&lt;p&gt;代表库 &lt;a href=&quot;https://jquery.com/&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo搭建静态博客</title>
    <link href="http://yoursite.com/2021/04/04/%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2021/04/04/用Hexo搭建静态博客/</id>
    <published>2021-04-04T15:05:16.564Z</published>
    <updated>2021-04-04T15:05:16.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>Git 安装及使用：<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的网站</a></li><li>Node.js 的安装：<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">Node.js 安装配置</a></li><li>Hexo 的安装及使用：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo 文档</a></li><li>yilia 主题的安装配置：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia 简介、安装、配置</a></li></ul><h2 id="hexo-环境配置"><a href="#hexo-环境配置" class="headerlink" title="hexo 环境配置"></a>hexo 环境配置</h2><ul><li>创建文件夹 blog 作为项目文件夹</li><li>初始化项目文件夹</li></ul><ul><li><p>指定文件夹初始化</p><pre><code>hexo init blog</code></pre></li><li><p>或者，进入文件夹再初始化</p><pre><code>cd bloghexo init</code></pre></li></ul><ul><li><p>安装插件 deployer</p><pre><code>npm install hexo-deployer-git --save</code></pre></li><li><p>修改根目录下的 _config.yml 文件</p><pre><code>deploy:type: gitrepo: git@github.com:JackXuyi/JackXuyi.github.io.gitbranch: master</code></pre></li><li><p>配置域名：在 source 目录下添加 CNAME 文件，并在文件里写入你的域名</p><pre><code>xuyi-emb.win</code></pre></li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul><li>源代码和发布的网站的存储位置不在同一个地方，使用不同分支保存数据，具体解释见 <a href="http://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用 hexo，如果换了电脑怎么更新博客？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Git 安装及使用：&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/00137
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>与native交互</title>
    <link href="http://yoursite.com/2021/04/04/%E4%B8%8Enative%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2021/04/04/与native交互/</id>
    <published>2021-04-03T20:06:35.000Z</published>
    <updated>2021-04-11T14:00:00.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hybird-App"><a href="#Hybird-App" class="headerlink" title="Hybird App"></a><code>Hybird App</code></h3><p>在 <code>Native App</code> 引用基础上结合了 <code>Web App</code> 应用所形成的模式，一般通过 <code>webview</code> 的模式引入</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>系统资源较少，包括 <code>CPU</code> 、内存、网卡、网络链接等。</li><li>支持更新的浏览器特性，不用考虑 <code>IE</code> 的兼容性问题</li><li>可以实现离线应用，通过新的浏览器特性或 <code>Native</code> 的文件读取机制进行文件级的文件缓存和离线更新</li><li>不同机型设备的兼容问题</li><li>可以调用客户端 <code>Native</code> 的能力，例如摄像头、定位、传感器、本地文件访问等。</li></ul><h3 id="Web-到-Native-的协议调用"><a href="#Web-到-Native-的协议调用" class="headerlink" title="Web 到 Native 的协议调用"></a><code>Web</code> 到 <code>Native</code> 的协议调用</h3><h4 id="通过-URI-请求"><a href="#通过-URI-请求" class="headerlink" title="通过 URI 请求"></a>通过 <code>URI</code> 请求</h4><p>在系统中注册一个 <code>Schema</code> 协议的 <code>URI</code> ，这个 <code>URI</code> 可以在系统的任意地方调起一段原生方法或一个原生的界面</p><p><img src="/images/webtonative.svg" alt="`web` 通过 `URI` 请求 `Native` 流程"></p><h4 id="通过-addJavascriptInterface-注入方法到页面中调用"><a href="#通过-addJavascriptInterface-注入方法到页面中调用" class="headerlink" title="通过 addJavascriptInterface 注入方法到页面中调用"></a>通过 <code>addJavascriptInterface</code> 注入方法到页面中调用</h4><p>通过 <code>addJavascriptInterface</code> 方法向页面中注入一个全局对象以供调用</p><h4 id="注入对象"><a href="#注入对象" class="headerlink" title="注入对象"></a>注入对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 ws 实例</span></span><br><span class="line">WebSettings ws = webView.getSetting();</span><br><span class="line"><span class="comment">// 开启执行 JavaScript 脚本</span></span><br><span class="line">ws.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 加载页面</span></span><br><span class="line">ws.loadUrl(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="comment">// 注入全局对象</span></span><br><span class="line">ws.addJavascriptInterface(<span class="keyword">new</span> Object(), <span class="string">"native"</span>)</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 调用注入的 native 方法</span></span></span><br><span class="line">    native.method()</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Native-到-Web-的调用"><a href="#Native-到-Web-的调用" class="headerlink" title="Native 到 Web 的调用"></a><code>Native</code> 到 <code>Web</code> 的调用</h3><ul><li>安卓：通过 <code>webView.loadUrl</code> 方法实现</li><li>iOS ：通过 <code>stringByEvaluatingJavaScriptFromString</code> 方法实现</li></ul><h4 id="html-定义方法"><a href="#html-定义方法" class="headerlink" title="html 定义方法"></a>html 定义方法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(msg)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="原生调用"><a href="#原生调用" class="headerlink" title="原生调用"></a>原生调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 ws 实例</span></span><br><span class="line">WebSettings ws = webView.getSetting();</span><br><span class="line"><span class="comment">// 开启执行 JavaScript 脚本</span></span><br><span class="line">ws.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 加载页面</span></span><br><span class="line">ws.loadUrl(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="comment">// 调用 js 方法</span></span><br><span class="line">webView.loadUr(<span class="string">"javascript: log('hello world')"</span>)</span><br></pre></td></tr></table></figure><h3 id="JSBridge"><a href="#JSBridge" class="headerlink" title="JSBridge"></a><code>JSBridge</code></h3><p>通信规则： <code>jsBridge://className:callbackMethod/methodName?jsonObj</code></p><h4 id="安卓实现"><a href="#安卓实现" class="headerlink" title="安卓实现"></a>安卓实现</h4><p>通过 <code>prompt</code> 方式调用。 <code>addJavascriptInterface</code> 存在安全漏洞，可以通过 <code>JavascriptInterface</code> 来解决，但是其存在兼容性问题。所以通过 <code>webView.setWebChromeClient</code> 来实现： <code>JavaScript</code> 在执行 <code>alert</code> 和 <code>prompt</code> 时， <code>Native</code> 端会自动触发 <code>onJsAlert</code> 和 <code>onJsPrompt</code> 的方法回调函数，由于 <code>alert</code> 比较常用，所以可以通过重写 <code>onJsPrompt</code> 的方法实现对 <code>Native</code> 端方法的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 prompt 监听</span></span><br><span class="line">webView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView wv, String url, String msg, String defaultValue, JsPromptResult res)</span> </span>&#123;</span><br><span class="line">        res.confirm(JSBridge.callJsPrompt(MainActivity.<span class="keyword">this</span>, wv, msg));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="iOS-实现"><a href="#iOS-实现" class="headerlink" title="iOS 实现"></a><code>iOS</code> 实现</h4><p>通过 <code>iframe</code> 的方式调用</p><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><ol><li>安卓通过 <code>prompt(jsBridge://className:callbackMethod/methodName?jsonObj)</code> 调用，<code>iOS</code> 通过 <code>iframe</code> 方式调用</li><li><code>Native</code> 解析协议，调用对应的 <code>className</code> 对象中的 <code>methodName</code> 方法，并把对应的参数 <code>jsonObj</code> 序列化后作为方法的参数</li><li>执行完成后调用 <code>JavaScript</code> 回调函数返回结果</li></ol><p><img src="/images/jsbridge.svg" alt="调用流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hybird-App&quot;&gt;&lt;a href=&quot;#Hybird-App&quot; class=&quot;headerlink&quot; title=&quot;Hybird App&quot;&gt;&lt;/a&gt;&lt;code&gt;Hybird App&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;Native App&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>实时协议</title>
    <link href="http://yoursite.com/2021/04/02/%E5%AE%9E%E6%97%B6%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2021/04/02/实时协议/</id>
    <published>2021-04-01T23:38:14.000Z</published>
    <updated>2021-04-03T12:03:25.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p><code>WebSocket</code> 是一种在单个 <code>TCP</code> 连接上进行全双工通信的协议，允许服务端主动向客户端推送数据。在 <code>WebSocket API</code> 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><a href="/2021/01/06/nodejs中实现websocket服务/">nodejs 中实现 websocket 服务</a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有 2 至 10 字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的 4 字节的掩码。相对于 HTTP 请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和 Comet 等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。与 HTTP 不同的是，Websocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而 HTTP 请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于 HTTP 压缩，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li></ul><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p><code>HTTP</code> 请求设置一个较长的超时等待时间，网络请求可以维持一个较长的时间来等待返回结果，如果在等待的时间内有结果会立即返回结果，如果没有结果就会超时自动断开链接，等待下一次请求。</p><p><img src="/images/long-poll.svg" alt="长轮询流程"></p><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>每隔一段时间定时向服务端发起一次请求拉取数据。</p><p><img src="/images/poll.svg" alt="短轮询流程"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin" target="_blank" rel="noopener">WebSocket</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;websocket&quot;&gt;&lt;a href=&quot;#websocket&quot; class=&quot;headerlink&quot; title=&quot;websocket&quot;&gt;&lt;/a&gt;websocket&lt;/h3&gt;&lt;p&gt;&lt;code&gt;WebSocket&lt;/code&gt; 是一种在单个 &lt;code&gt;TCP&lt;/c
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="http://yoursite.com/2021/03/28/HTTPS/"/>
    <id>http://yoursite.com/2021/03/28/HTTPS/</id>
    <published>2021-03-27T20:13:54.000Z</published>
    <updated>2021-04-03T12:00:59.354Z</updated>
    
    <content type="html"><![CDATA[<p><code>HTTPS</code> 协议是通过加入 <code>SSL</code> 层来加密 <code>HTTP</code> 数据进行安全通信的</p><h3 id="HTTPS-建立链接的过程"><a href="#HTTPS-建立链接的过程" class="headerlink" title="HTTPS 建立链接的过程"></a><code>HTTPS</code> 建立链接的过程</h3><ol><li>客户端发起请求，携带客户端支持加密算法，同时携带随机串 1</li><li>服务端收到请求后与自己支持的加密算法进行比对，从双方都支持的加密算法中选择一个返回，同时返回域名相关的公钥和证书签名信息（包括证书时间、日期、颁发机构）及随机串 2</li><li>客户端收到响应后验证证书的合法性和公钥的正确性（通过请求证书颁发机构来验证证书的合法性）</li><li>证书验证通过后，利用公钥加密一个随机字符串作为后续传输数据的密钥，同时加入利用公钥加密随机串 1 和随机串 2 组成的握手信息，然后发送给服务端</li><li>服务端获取到信息后利用私钥进行解密得到客户端生成的随机字符串把它作为后续传输的密钥，利用密钥对传输的随机串 1 和随机串 2 进行加密，然后返回</li><li>客户端利用上述生成的随机串对返回的信息进行解密，然后验证其合法性，后续传输就是堆成加密传输</li></ol><p><img src="/images/https.svg" alt="HTTPS 获取密钥过程"></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://www.jianshu.com/p/33d0f8631f90" target="_blank" rel="noopener">https 建立连接过程</a></li><li><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617" target="_blank" rel="noopener">HTTP 和 HTTPS 协议，看一篇就够了</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt; 协议是通过加入 &lt;code&gt;SSL&lt;/code&gt; 层来加密 &lt;code&gt;HTTP&lt;/code&gt; 数据进行安全通信的&lt;/p&gt;
&lt;h3 id=&quot;HTTPS-建立链接的过程&quot;&gt;&lt;a href=&quot;#HTTPS-建立链接的过程&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>网络安全</title>
    <link href="http://yoursite.com/2021/03/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2021/03/28/网络安全/</id>
    <published>2021-03-27T19:34:30.000Z</published>
    <updated>2021-04-01T15:50:46.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端攻击"><a href="#前端攻击" class="headerlink" title="前端攻击"></a>前端攻击</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><code>XSS</code></h4><p>跨站脚本攻击，由插入页面处理的数据未经处理导致。</p><ul><li>存储型 <code>XSS</code> ：提交的数据未经处理存储到数据库中，然后从数据库中获取数据插入页面导致的</li><li>反射型 <code>XSS</code> ：通过 <code>URL</code> 提取参数未经处理直接插入到页面导致</li><li><code>MXSS</code> ：渲染 <code>DOM</code> 时插入了攻击脚本（模板渲染）</li></ul><p>通过字符转义的方式把特殊的符号转化为安全的 <code>HTML</code> 字符（如 &lt;、&gt;等）</p><h4 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a><code>SQL</code> 注入攻击</h4><p>结构性查询语言注入攻击，页面提交的数据直接拼接到 <code>SQL</code> 语句进行操作导致，通过对查询数据进行合法性校验即可避免</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a><code>CSRF</code></h4><p>跨站请求伪造，非源站点按照源站点数据格式提交非法数据给源站点的一种攻击方式。大部分网站是通过 <code>COOKIE</code> 的方式来验证登录的用户信息，由于浏览器的策略导致请求时会自动携带相关 <code>COOKIE</code>，当非源站点请求源站点数据时也会携带相关 <code>COOKIE</code>，此时构造一个非法的请求也会请求成功。解决办法就是通过在页面中预先植入 <code>TOKEN</code> ，在接口请求时再手动携带上相关的值，由于浏览器的安全策略限制非源站点无法读取相关数据进而导致请求失败</p><h3 id="网络劫持"><a href="#网络劫持" class="headerlink" title="网络劫持"></a>网络劫持</h3><p>网络资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。</p><h4 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a><code>DNS</code> 劫持</h4><p>攻击者通过篡改 <code>DNS</code> 服务器的域名解析记录，导致用户无法访问正确的网络 <code>IP</code> ，而是访问篡改后的错误 <code>IP</code> 地址。</p><h4 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a><code>HTTP</code> 劫持</h4><p>在用户浏览器和访问的目的服务器之间建立的网络数据传输通道中从网关或防火墙层上监视特定的数据信息，当满足特定条件时，就会在正常的数据包中插入或篡改网络数据包（如 <code>ISP</code> 在部分第三方网站页面中植入广告）。可以通过 <code>HTTPS</code> 协议来预防</p><h3 id="浏览器-WEB-安全控制"><a href="#浏览器-WEB-安全控制" class="headerlink" title="浏览器 WEB 安全控制"></a>浏览器 <code>WEB</code> 安全控制</h3><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a><code>X-XSS-Protection</code></h4><p>防止反射型 <code>XSS</code> 问题的发生，浏览器层面增强前端网页的安全性。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">0</span> <span class="comment"># 禁止XSS过滤。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span> <span class="comment"># 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span><span class="string">;</span> <span class="string">mode=block</span> <span class="comment"># 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</span></span><br><span class="line"><span class="attr">X-XSS-Protection:</span> <span class="number">1</span><span class="string">;</span> <span class="string">report=&lt;reporting-uri&gt;</span> <span class="comment"># 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri (en-US)指令的功能发送违规报告。</span></span><br></pre></td></tr></table></figure><h4 id="Strict-Transport-Security"><a href="#Strict-Transport-Security" class="headerlink" title="Strict-Transport-Security"></a><code>Strict-Transport-Security</code></h4><p>配置浏览器和服务器之间安全通信的机制，防止中间者攻击（强制使用 <code>HTTPS</code> 协议，普通协议无效）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;</span> <span class="comment"># 设置在浏览器收到这个请求后的&lt;expire-time&gt;秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。</span></span><br><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;;</span> <span class="string">includeSubDomains</span> <span class="comment"># 如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。</span></span><br><span class="line"><span class="attr">Strict-Transport-Security:</span> <span class="string">max-age=&lt;expire-time&gt;;</span> <span class="string">preload</span> <span class="comment"># 查看 预加载 HSTS 获得详情。不是标准的一部分。</span></span><br></pre></td></tr></table></figure><h4 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content-Security-Policy"></a><code>Content-Security-Policy</code></h4><p>开发者定义的安全策略性声明，浏览器只可以加载指定可信域名来源的内容（包括脚本、图片、<code>iframe</code>、<code>font</code>、<code>style</code> 等）</p><h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a><code>Access-Control-Allow-Origin</code></h4><p>决定哪些网站可以访问当前服务器资源，通过定义通配符可以让所有网站来访问当前网站的所有资源。若 <code>Access-Control-Allow-Origin</code> 为 <code>*</code>，则 <code>Access-Control-Allow-Credentials</code> 无效。若想 <code>Access-Control-Allow-Credentials</code> 有效（即请求携带 <code>Cookie</code>），则必须明确配置来源。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection" target="_blank" rel="noopener"><code>X-XSS-Protection</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security" target="_blank" rel="noopener"><code>Strict-Transport-Security</code></a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener"><code>Content-Security-Policy</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin" target="_blank" rel="noopener"><code>Access-Control-Allow-Origin</code></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前端攻击&quot;&gt;&lt;a href=&quot;#前端攻击&quot; class=&quot;headerlink&quot; title=&quot;前端攻击&quot;&gt;&lt;/a&gt;前端攻击&lt;/h3&gt;&lt;h4 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;&lt;c
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://yoursite.com/2021/03/22/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2021/03/22/http协议/</id>
    <published>2021-03-21T16:41:21.000Z</published>
    <updated>2021-03-21T13:30:20.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p>发布于 1999 年，默认使用文本格式传输数据</p><h4 id="长链接"><a href="#长链接" class="headerlink" title="长链接"></a>长链接</h4><p>默认包含 <code>Connection: keep-alive</code> 头，可以让客户端和服务端在一段时间内可以复用这个链接，无需再次建立链接。链接复用发生在应用层，且复用是串行的</p><h4 id="协议扩展切换"><a href="#协议扩展切换" class="headerlink" title="协议扩展切换"></a>协议扩展切换</h4><p>支持在请求头部域消息中包含 <code>Upgrade</code> 头并让客户端通过头部标识令服务器知道它能够支持其它备用通信协议的一种机制，服务器根据客户端请求的其它协议进行切换，切换后使用备用协议与客户端进行通信</p><h4 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h4><p>新增 <code>Cache-Control</code> 字段，支持 <code>max-age</code> 用来表示相对过期时间；服务器也可以通过 <code>Etag</code> 和 <code>Last-Modified</code> 来判断是否从浏览器中加载文件，此时缓存的控制和判断将决定响应状态码是 200 还是 304。参考<a href="/2020/08/31/浏览器缓存/">浏览器缓存</a>章节</p><h4 id="部分内容传输优化"><a href="#部分内容传输优化" class="headerlink" title="部分内容传输优化"></a>部分内容传输优化</h4><p>引入了 <code>range</code> 头域支持超文本文件的部分传输。如允许请求一个文件的起始位置和偏移长度来进行文件内容的部分传输</p><h4 id="Host-头处理"><a href="#Host-头处理" class="headerlink" title="Host 头处理"></a>Host 头处理</h4><p>请求消息和响应消息都支持 <code>Host</code> 头域，且请求消息中如果没有 <code>Host</code> 头域会报告一个错误（<code>400 Bad Request</code>）</p><h4 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h4><p>新增了 <code>24</code> 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><ul><li>采用完全的二进制格式来传输数据，其在网络中以帧的形式传播，多个帧在网络中形成了帧的传输网络流，即流式传播的。</li><li>使用 <code>TCP</code> 复用的方式来降低网络请求链接的建立和关闭的开销，多个请求可以通过一个链接来进行并发完成。复用发生在传输层，是帧的多路复用，不同文件的传输可以在一个 <code>TCP</code> 连接中一起同时进行流式传播</li><li>支持传输流的优先级和流量控制机制</li><li>支持服务端推送</li></ul><h4 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a><code>SPDY</code> 协议</h4><p>使用 <code>SSL</code> 传输协议，支持多路复用和服务端推送技术，压缩 <code>HTTP</code> 头部以减少传输大小</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP-1-1&quot;&gt;&lt;a href=&quot;#HTTP-1-1&quot; class=&quot;headerlink&quot; title=&quot;HTTP 1.1&quot;&gt;&lt;/a&gt;HTTP 1.1&lt;/h3&gt;&lt;p&gt;发布于 1999 年，默认使用文本格式传输数据&lt;/p&gt;
&lt;h4 id=&quot;长链接&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>commonjs</title>
    <link href="http://yoursite.com/2021/03/03/commonjs/"/>
    <id>http://yoursite.com/2021/03/03/commonjs/</id>
    <published>2021-03-02T23:44:49.000Z</published>
    <updated>2021-03-20T15:40:03.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commonjs-规范"><a href="#commonjs-规范" class="headerlink" title="commonjs 规范"></a>commonjs 规范</h3><ul><li>模块引用：通过 <code>require</code> 方法把模块引入上下文</li><li>模块定义：模块中通过 <code>exports</code> 属性导出模块的方法和变量，<code>module</code> 代表模块自身</li><li>模块标识：传递给 <code>require</code> 方法的参数</li></ul><h3 id="node-实现"><a href="#node-实现" class="headerlink" title="node 实现"></a>node 实现</h3><h5 id="引入模块的流程"><a href="#引入模块的流程" class="headerlink" title="引入模块的流程"></a>引入模块的流程</h5><ol><li>路径分析</li><li>文件定位</li><li>编译执行</li></ol><h5 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h5><ol><li>核心模块：<code>Node</code> 源代码的编译过程中，编译进了二进制执行文件。<code>Node</code> 启动时已经被加载入内存中</li><li>文件模块：运行时动态加载</li></ol><h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><ol><li>引入过的模块都会进行缓存</li><li>缓存优先</li></ol><h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p><code>Node</code> 中在定位文件模块的具体文件时制定的查找策略，根据查找规则生成查找路径数组，查找规则如下</p><ol><li>查找当前目录下的 <code>node_modules</code> 目录</li><li>父目录下的 <code>node_modules</code> 目录</li><li>沿着路径向上逐级递归直到找到根目录的 <code>node_modules</code> 目录</li></ol><h5 id="模块标志符分析"><a href="#模块标志符分析" class="headerlink" title="模块标志符分析"></a>模块标志符分析</h5><ul><li>核心模块</li><li>相对路径模块和绝对路径模块：转化为真实路径作为索引来查找和缓存模块</li><li>非路径形式的文件模块</li></ul><h5 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h5><ul><li>文件扩展名分析：<code>Node</code> 会按照 <code>.js</code>、<code>.json</code>、<code>.node</code>的次序依次尝试扩展名，尝试过程中会阻塞式的判断文件是否存在</li><li>目录分析与包：分析标识符得到一个文件夹时，<code>Node</code> 会按照 <code>package.json</code>、<code>index.js</code>、<code>index.json</code>、<code>index.node</code>来查找文件，若查找到 <code>package.json</code> 会提取 <code>main</code> 指定的文件来进行定位</li></ul><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>定位到具体的文件之后，<code>Node</code> 会构建一个模块对象，然后根据路径载入并编译</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id</span><br><span class="line">  <span class="keyword">this</span>.parent = parent</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;</span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>.children = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不同扩展名的载入方式"><a href="#不同扩展名的载入方式" class="headerlink" title="不同扩展名的载入方式"></a>不同扩展名的载入方式</h5><ul><li><code>.js</code> 文件：通过 <code>fs</code> 模块同步读取文件后编译执行</li><li><code>.node</code> 文件：<code>c/c++</code> 写的扩展文件，通过 <code>dlopen()</code> 方法加载编译生成的文件</li><li><code>.json</code> 文件：通过 <code>fs</code> 模块同步读取文件后返回 <code>JSON.parse</code> 的结果</li><li>其它类型的文件：当作 <code>.js</code> 文件来处理</li></ul><h6 id="注：-可以通过-require-extensions-quot-ext-quot-的方式来扩展方式，但是已不推荐"><a href="#注：-可以通过-require-extensions-quot-ext-quot-的方式来扩展方式，但是已不推荐" class="headerlink" title="注： 可以通过 require.extensions[&quot;.ext&quot;] 的方式来扩展方式，但是已不推荐"></a>注： 可以通过 <code>require.extensions[&quot;.ext&quot;]</code> 的方式来扩展方式，但是已不推荐</h6><h5 id="JavaScript-模块的编译"><a href="#JavaScript-模块的编译" class="headerlink" title="JavaScript 模块的编译"></a><code>JavaScript</code> 模块的编译</h5><p><code>Node</code> 对获取的 <code>JavaScript</code> 文件内容做了包装，在头部添加了 <code>(function(exports, require, module, __filename, __dirname){\n</code>，在尾部添加了 <code>\n})</code>，包装之后的代码会通过 <code>vm</code> 原生的 <code>runInThisContext()</code> 方法执行，返回一个 <code>function</code> 对象，然后将当前模块对象的 <code>exports</code> 属性、<code>require</code> 方法、 <code>module</code>（模块对象自身）、模块定位中的完整文件路径和目录作为参数传递给这个函数执行，执行之后模块的 <code>exports</code> 属性被返回给了调用方</p><h6 id="注：-exports-属性是作为形参传入的，直接赋值会改变形参的引用，通过-module-exports-赋值采用迂回的方案不改变形参的引用"><a href="#注：-exports-属性是作为形参传入的，直接赋值会改变形参的引用，通过-module-exports-赋值采用迂回的方案不改变形参的引用" class="headerlink" title="注： exports 属性是作为形参传入的，直接赋值会改变形参的引用，通过 module.exports 赋值采用迂回的方案不改变形参的引用"></a>注： <code>exports</code> 属性是作为形参传入的，直接赋值会改变形参的引用，通过 <code>module.exports</code> 赋值采用迂回的方案不改变形参的引用</h6><h5 id="c-c-模块的编译"><a href="#c-c-模块的编译" class="headerlink" title="c/c++ 模块的编译"></a><code>c/c++</code> 模块的编译</h5><p><code>Node</code> 调用 <code>process.dlopen</code> 方法进行加载和执行，模块的 <code>exports</code> 对象和 <code>.node</code> 模块产生联系并返回给调用者</p><ul><li>优点： 执行效率高</li><li>缺点：门槛高</li></ul><h5 id="JSON-文件的编译"><a href="#JSON-文件的编译" class="headerlink" title="JSON 文件的编译"></a><code>JSON</code> 文件的编译</h5><p><code>Node</code> 利用 <code>fs</code> 模块同步读取 <code>JSON</code> 文件内容之后，调用 <code>JSON.parse</code> 方法得到对象，然后赋值给对象的 <code>exports</code> 属性供外部调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;commonjs-规范&quot;&gt;&lt;a href=&quot;#commonjs-规范&quot; class=&quot;headerlink&quot; title=&quot;commonjs 规范&quot;&gt;&lt;/a&gt;commonjs 规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;模块引用：通过 &lt;code&gt;require&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>浏览器基础</title>
    <link href="http://yoursite.com/2021/03/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/03/02/浏览器基础/</id>
    <published>2021-03-01T23:06:23.000Z</published>
    <updated>2021-03-20T14:22:31.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h3><h4 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h4><p>包括浏览器中可见的地址输入框、浏览器前进返回按钮、打开书签、打开历史记录等用户可操作的功能选项</p><h4 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h4><p>可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器各个部分通信的核心。</p><h4 id="渲染引擎（内核）"><a href="#渲染引擎（内核）" class="headerlink" title="渲染引擎（内核）"></a>渲染引擎（内核）</h4><p>解析 <code>DOM</code> 文档和 <code>CSS</code> 规则并将内容排版到浏览器中显示有样式的界面</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>开启网络线程发送请求或下载资源文件</p><h4 id="UI-后端"><a href="#UI-后端" class="headerlink" title="UI 后端"></a>UI 后端</h4><p>绘制基本的浏览器窗口内的控件，比如组合选择框、按钮、输入框等</p><h4 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a><code>JavaScript</code> 引擎</h4><p>解析和执行 <code>JavaScript</code> 脚本，比如 <code>V8</code> 引擎</p><h4 id="持久化数据存储"><a href="#持久化数据存储" class="headerlink" title="持久化数据存储"></a>持久化数据存储</h4><p>数据持久化存储，涉及 <code>cookie</code> 、 <code>localStorage</code> 等客户端存储技术</p><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ol><li>解析 <code>HTML</code> 构建 <code>DOM</code>树：将 HTML 元素标签解析成由多个 DOM 元素对象节点组成的具有节点父子关系的 DOM 树结构</li><li>构建渲染树：按顺序提取 DOM 元素对象的样式数据，构建带样式描述的 DOM 渲染树对象</li><li>渲染布局阶段：根据节点的大小和位置把元素绘制在页面上，主要是布局属性（例如： postion、float、margin、padding 等）生效</li><li>绘制渲染树：将节点的背景、颜色、文本等样式信息应用到节点上，主要是元素的内部显示样式（例如： color、background、text-shadow 等）生效</li></ol><h4 id="gecko-内核渲染流程"><a href="#gecko-内核渲染流程" class="headerlink" title="gecko 内核渲染流程"></a>gecko 内核渲染流程</h4><p>先解析 HTM，生成内容 Sink （Content Sink 可以认为是构建 DOM 结构树的工厂方法），再开始解析 CSS</p><p><img src="/images/brower/gecko.svg" alt="gecko内核渲染流程"></p><h4 id="webkit-内核渲染流程"><a href="#webkit-内核渲染流程" class="headerlink" title="webkit 内核渲染流程"></a>webkit 内核渲染流程</h4><p>HTML 和 CSS 的解析是并行的</p><p><img src="/images/brower/webkit.svg" alt="webkit内核渲染流程"></p><h3 id="持久化技术"><a href="#持久化技术" class="headerlink" title="持久化技术"></a>持久化技术</h3><ul><li><a href="/2020/08/31/浏览器缓存/">HTTP 文件缓存</a></li><li><code>localStorage</code></li><li><code>sessionStorage</code></li><li><code>cookie</code></li><li><code>webSQL</code></li><li><code>Application cache</code></li><li><code>cacheStorage</code></li><li><code>flash</code> 缓存</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器组成&quot;&gt;&lt;a href=&quot;#浏览器组成&quot; class=&quot;headerlink&quot; title=&quot;浏览器组成&quot;&gt;&lt;/a&gt;浏览器组成&lt;/h3&gt;&lt;h4 id=&quot;用户界面&quot;&gt;&lt;a href=&quot;#用户界面&quot; class=&quot;headerlink&quot; title=&quot;用户界面&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>简单代码热更新</title>
    <link href="http://yoursite.com/2021/02/28/%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2021/02/28/简单代码热更新/</id>
    <published>2021-02-28T15:19:45.000Z</published>
    <updated>2021-02-28T08:30:17.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li>开发静态页面修改样式时需要手动刷新页面才会在页面上看到效果比较麻烦</li><li>了解了热更新原理需要实践下</li><li>手动实现了<a href="/2021/01/06/nodejs中实现websocket服务/">对 <code>websocket</code> 的解析</a>，趁热打铁把 <code>websocket</code> 应用在实际项目中</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>服务端监听文件改动</li><li>当文件有改动之后服务端发送事件通知客户端</li><li>客户端接收到事件之后做出对应的处理</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="服务端监听文件改动"><a href="#服务端监听文件改动" class="headerlink" title="服务端监听文件改动"></a>服务端监听文件改动</h4><p>nodejs 在 <code>fs</code> 模块中提供了两个监听文件改动的方法 <code>fs.watch</code> 和 <code>fs.watchFile</code> 两个方法。</p><h5 id="fs-watch-参考"><a href="#fs-watch-参考" class="headerlink" title="fs.watch 参考"></a><a href="http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener" target="_blank" rel="noopener"><code>fs.watch</code> 参考</a></h5><p>监听文件及文件夹下的改动，通过如下方式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.watch(filename[, options], listener)</span><br></pre></td></tr></table></figure><ul><li><code>filename</code>: 文件或目录</li><li><code>options</code>: 可选的，如果 options 传入字符串，则它指定 encoding。 否则，options 应传入对象，属性如下：<ul><li><code>persistent</code>: &lt;<code>boolean</code>&gt; 指示如果文件已正被监视，进程是否应继续运行。默认值: <code>true</code></li><li><code>recursive</code>: &lt;<code>boolean</code>&gt; 指示应该监视所有子目录，还是仅监视当前目录。这适用于监视目录时，并且仅适用于受支持的平台（参见注意事项）。默认值: <code>false。</code></li><li><code>encoding</code>: &lt;<code>string</code>&gt; 指定用于传给监听器的文件名的字符编码。默认值: <code>utf8</code>。</li></ul></li><li><code>listener</code>: 监听器回调有两个参数 <code>(eventType, filename)</code>。 <code>eventType</code> 是 <code>rename</code> 或 <code>change</code>， <code>filename</code> 是触发事件的文件的名称。</li></ul><h5 id="fs-watchFile-参考"><a href="#fs-watchFile-参考" class="headerlink" title="fs.watchFile 参考"></a><a href="http://nodejs.cn/api/fs.html#fs_fs_watchfile_filename_options_listener" target="_blank" rel="noopener"><code>fs.watchFile</code> 参考</a></h5><p>监听特定文件的改动，通过如下方式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure><ul><li><code>filename</code>: 文件</li><li><code>options</code>: 可选的，options 应传入对象，属性如下：<ul><li><code>persistent</code>: &lt;<code>boolean</code>&gt; 指示如果文件已正被监视，进程是否应继续运行。默认值: <code>true</code>。</li><li><code>interval</code>: 指示轮询目标的频率（以毫秒为单位）。</li><li><code>bigint</code>: 回调函数的参数对象是否为<code>BigInts</code>类型。</li></ul></li><li><code>listener</code>: 监听器回调有两个参数 <code>(curr, prev)</code>。 <code>curr</code> 是文件修改后的 <code>fs.Stat</code> 实例， <code>prev</code> 是文件修改前的 <code>fs.Stat</code> 实例。</li></ul><h4 id="通知客户端"><a href="#通知客户端" class="headerlink" title="通知客户端"></a>通知客户端</h4><p>通过建立一个 <code>websocket</code> 服务的方式，当文件有变更的时候发送更新消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'upgrade'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, socket, head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> read = <span class="keyword">new</span> WebsocketRead(req, socket)</span><br><span class="line">  <span class="keyword">const</span> write = <span class="keyword">new</span> WebsocketWrite(socket)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'websocket connect success'</span>)</span><br><span class="line"></span><br><span class="line">  read.on(<span class="string">'text'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接收到响应'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  read.on(<span class="string">'ping'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    write.pong()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  watch.on(<span class="string">'update'</span>, (data) =&gt; &#123;</span><br><span class="line">    write.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="客户端处理事件"><a href="#客户端处理事件" class="headerlink" title="客户端处理事件"></a>客户端处理事件</h4><p>在客户端插入建立 <code>websocket</code> 链接的代码，接收到更新之后重新刷新页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">`ws://\$&#123;location.host&#125;`</span>)</span></span><br><span class="line"><span class="javascript">  socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = e.data</span></span><br><span class="line">    location.reload()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="自动注入建立-websocket-链接的代码"><a href="#自动注入建立-websocket-链接的代码" class="headerlink" title="自动注入建立 websocket 链接的代码"></a>自动注入建立 <code>websocket</code> 链接的代码</h4><p>返回 <code>HTML</code> 页面时通过正则的方式在页面中插入代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.readFileSync(filePath)</span><br><span class="line"><span class="keyword">if</span> (path.extname(filePath) === <span class="string">'.html'</span>) &#123;</span><br><span class="line">  data = data</span><br><span class="line">    .toString()</span><br><span class="line">    .replace(<span class="regexp">/\&lt;\/\s*body&gt;/</span>, <span class="string">`<span class="subst">$&#123;websocketTemplateStr&#125;</span>&lt;/body&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对文件修改监听的封装"><a href="#对文件修改监听的封装" class="headerlink" title="对文件修改监听的封装"></a>对文件修改监听的封装</h4><p>通过封装成对应的方式，利用事件总线的模式实现事件的派发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">'events'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolveRootPath &#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(dir) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.watchPath = resolveRootPath(dir)</span><br><span class="line">    fs.watch(<span class="keyword">this</span>.watchPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="keyword">this</span>.handleCallback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCallback = <span class="function">(<span class="params">eventType, filename</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> content = fs</span><br><span class="line">        .readFileSync(path.resolve(<span class="keyword">this</span>.watchPath, filename), &#123;</span><br><span class="line">          encoding: <span class="string">'utf-8'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .toString()</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'update'</span>, &#123;</span><br><span class="line">        filename,</span><br><span class="line">        content,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'remove'</span>, &#123;</span><br><span class="line">        filename,</span><br><span class="line">        content: <span class="literal">null</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Watch</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><code>fs.watch</code> 和 <code>fs.watchFile</code> 兼容性考虑，在不兼容的平台上可以通过定时检查文件的方式判断文件是否有改动</li><li><code>websocket</code> 兼容性考虑，不支持的平台上降级为短轮询或长轮询的方式</li><li>文件修改时可以在抛出的事件中提供更多的信息，事件局部文件的热更新而不用刷新整个页面</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener"><code>nodejs</code> <code>fs</code> 模块</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/WebSocket" target="_blank" rel="noopener">浏览器<code>websocket</code></a></li><li><a href="/2021/01/06/nodejs中实现websocket服务/">nodejs 中实现 websocket 服务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发静态页面修改样式时需要手动刷新页面才会在页面上看到效果比较麻烦&lt;/li&gt;
&lt;li&gt;了解了热更新原理需要实践下&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>粘贴图片</title>
    <link href="http://yoursite.com/2021/01/24/%E7%B2%98%E8%B4%B4%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2021/01/24/粘贴图片/</id>
    <published>2021-01-23T22:16:19.000Z</published>
    <updated>2021-01-23T15:13:36.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>优化用户编辑体验，实现在编辑内容（markdown 或富文本）时通过复制的方式实现图片的插入</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>监听剪贴板事件中的 <code>paste</code> 事件</li><li>通过事件的回调对象获取粘贴内容，若为文本则执行默认操作，若为图片类型则阻止默认操作并继续处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cb = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = event.clipboardData <span class="comment">// 获取粘贴内容</span></span><br><span class="line">  <span class="keyword">let</span> fileContent</span><br><span class="line">  <span class="keyword">let</span> stopFlag = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 遍历对象获取粘贴文件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; data &amp;&amp; data.items &amp;&amp; i &lt; data.items.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = data.items[i]</span><br><span class="line">    <span class="keyword">if</span> (item.kind === <span class="string">'file'</span> &amp;&amp; item.type.match(<span class="string">'^image/'</span>)) &#123;</span><br><span class="line">      stopFlag = <span class="literal">true</span></span><br><span class="line">      fileContent = item.getAsFile()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 fileContent 做处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><code>event</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ClipboardEvent" target="_blank" rel="noopener"><code>ClipboardEvent</code></a> 类型，可以通过 <code>clipboardData</code> 属性拿到数据内容</li><li><code>clipboardData</code> 是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransfer" target="_blank" rel="noopener"> DataTransfer`</a>对象，在粘贴事件中可以通过 <code>items</code> 属性获取粘贴的内容和数据类型，其是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransferItemList" target="_blank" rel="noopener"><code>DataTransferItemList</code></a> 对象，通过 <code>for</code> 循环的方式遍历每一个元素，每个元素都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DataTransferItem" target="_blank" rel="noopener"><code>DataTransferItem</code></a>对象</li></ul><h4 id="DataTransferItem-对象"><a href="#DataTransferItem-对象" class="headerlink" title="DataTransferItem 对象"></a><code>DataTransferItem</code> 对象</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><code>kind</code>： 拖拽项的种类，<code>string</code> 或是 <code>file</code></li><li><code>type</code>：拖拽项的类型，一般是一个 MIME 类型</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><code>getAsFile()</code>：返回一个关联拖拽项的 File 对象 （当拖拽项不是一个文件时返回 null）</li><li><code>getAsString()</code>：使用拖拽项的字符串作为参数执行指定回调函数。</li><li><code>webkitGetAsEntry()</code>：返回一个基于 FileSystemEntry 的对象来表示文件系统中选中的项目。通常是返回一个 FileSystemFileEntry 或是 FileSystemDirectoryEntry 对象.</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>在 <code>mac</code> 上复制一张图片文件时会产生两个记录，第一个记录是文件名，第二个对象是文件本身</li><li>在 <code>mac</code> 上复制一个非图片类型的文件时，也会产生两个记录，一个是文件名，另一个是文件的缩略图，但是这个文章的缩略图通过 <code>getAsFile</code> 方法无法获取到内容</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/paste" target="_blank" rel="noopener">paste 事件</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;优化用户编辑体验，实现在编辑内容（markdown 或富文本）时通过复制的方式实现图片的插入&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>跨页面通信</title>
    <link href="http://yoursite.com/2021/01/17/%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2021/01/17/跨页面通信/</id>
    <published>2021-01-17T13:37:39.000Z</published>
    <updated>2021-01-17T14:59:28.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在浏览器中每个页面都运行在单独的进程中，如何实现页面间的通信？</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><h4 id="BroadCastChannel"><a href="#BroadCastChannel" class="headerlink" title="BroadCastChannel"></a>BroadCastChannel</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel" target="_blank" rel="noopener">BroadcastChannel</a> 接口代理了一个命名频道，可以让指定 origin 下的任意 browsing context 来订阅它。它允许同源的不同浏览器窗口，Tab 页，frame 或者 iframe 下的不同文档之间相互通信。通过触发一个 <code>message</code> 事件，消息可以广播到所有监听了该频道的 <code>BroadcastChannel</code> 对象。</p><ol><li>构建一个实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bc = <span class="keyword">new</span> BroadcastChannel(<span class="string">'channel'</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>调用 <code>postMessage</code> 发送消息</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(data)</span><br></pre></td></tr></table></figure><ol start="3"><li>分别监听 <code>onmessage</code> 和 <code>onmessageerror</code> 事件来接收数据和错误消息</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.data是发送过来的数据，可以根据数据做一些事情</span></span><br><span class="line">&#125;</span><br><span class="line">bc.onmessageerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用 <code>close</code> 关闭通道，并销毁 <code>BroadcastChannel</code> 对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.close()</span><br></pre></td></tr></table></figure><h4 id="localStorage-实现"><a href="#localStorage-实现" class="headerlink" title="localStorage 实现"></a>localStorage 实现</h4><p>当前页面使用的 <code>storage</code> 被其他页面修改时会触发 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/StorageEvent" target="_blank" rel="noopener"><code>StorageEvent</code></a> 事件</p><ol><li>在源页面设置值触发事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'newValue'</span>, <span class="string">'new'</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收页面监听 <code>storage</code> 事件以实现通信</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// e.newValue表示新设置的值</span></span><br><span class="line">  <span class="comment">// e.key表示新设置的值的键</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h4><ol><li><code>Service Worker</code>: 一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。</li><li><code>Shared Worker</code>: Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</li><li><code>IndexedDB</code>: 数据存储技术</li><li><code>window.open + window.opener</code>: 当我们使用 window.open 打开页面时，方法会返回一个被打开页面 window 的引用。而在未显示指定 no opener 时，被打开的页面可以通过 window.opener 获取到打开它的页面的引用 —— 通过这种方式我们就将这些页面建立起了联系（一种树形结构）。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilitychange_event" target="_blank" rel="noopener"><code>visibilitychange</code></a>: 当其选项卡的内容变得可见或被隐藏时，会在文档上触发 visibilitychange (能见度更改)事件。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/kd-cloud-web/Blog/issues/41" target="_blank" rel="noopener">几种跨页面通信的方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/81237384" target="_blank" rel="noopener">跨页面的通信解决方案</a></li><li><a href="https://juejin.cn/post/6844903495636615176" target="_blank" rel="noopener">跨页面通信的各种姿势</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在浏览器中每个页面都运行在单独的进程中，如何实现页面间的通信？&lt;/p&gt;
&lt;h3 id=&quot;实现方案&quot;&gt;&lt;a href=&quot;#实现方案&quot; clas
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>nodejs中实现websocket服务</title>
    <link href="http://yoursite.com/2021/01/06/nodejs%E4%B8%AD%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2021/01/06/nodejs中实现websocket服务/</id>
    <published>2021-01-05T22:57:14.000Z</published>
    <updated>2021-04-01T15:51:01.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h3><p>若要实现 WebSocket 协议，首先需要浏览器主动发起一个 HTTP 请求。</p><p>这个请求头包含“Upgrade”字段，内容为“websocket”（注：upgrade 字段用于改变 HTTP 协议版本或换用其他协议，这里显然是换用了 websocket 协议），还有一个最重要的字段“Sec-WebSocket-Key”，这是一个随机的经过 base64 编码的字符串，像密钥一样用于服务器和客户端的握手过程。一旦服务器君接收到来自客户端的 upgrade 请求，便会将请求头中的“Sec-WebSocket-Key”字段提取出来，追加一个固定的“魔串”：<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>，并进行 SHA-1 加密，然后再次经过 base64 编码生成一个新的 key，作为响应头中的“Sec-WebSocket-Accept”字段的内容返回给浏览器。一旦浏览器接收到来自服务器的响应，便会解析响应中的“Sec-WebSocket-Accept”字段，与自己加密编码后的串进行匹配，一旦匹配成功，便有建立连接的可能了（因为还依赖许多其他因素）。</p><p>这是一个基本的 Client 请求头：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Upgrade:</span> <span class="string">websocket</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">Upgrade</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Key:</span> <span class="string">************==</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Version:</span> <span class="string">**</span></span><br></pre></td></tr></table></figure><p>Server 正确接收后，会返回一个响应头：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Upgrade：websocket</span></span><br><span class="line"><span class="attr">Connnection:</span> <span class="string">Upgrade</span></span><br><span class="line"><span class="attr">Sec-WebSocket-Accept:</span> <span class="string">******************</span></span><br></pre></td></tr></table></figure><p>这表示双方握手成功了，之后就是全双工的通信。</p><h4 id="js-代码实现"><a href="#js-代码实现" class="headerlink" title="js 代码实现"></a>js 代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建响应头</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildHeaders</span>(<span class="params">secWebsocketKey</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计算返回的key</span></span><br><span class="line">  <span class="keyword">const</span> resKey = crypto</span><br><span class="line">    .createHash(<span class="string">'sha1'</span>)</span><br><span class="line">    .update(secWebsocketKey + <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>)</span><br><span class="line">    .digest(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造响应头</span></span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'HTTP/1.1 101 Switching Protocols'</span>,</span><br><span class="line">    <span class="string">'Upgrade: websocket'</span>,</span><br><span class="line">    <span class="string">'Connection: Upgrade'</span>,</span><br><span class="line">    <span class="string">'Sec-WebSocket-Accept: '</span> + resKey,</span><br><span class="line">  ]</span><br><span class="line">    .concat(<span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line">    .join(<span class="string">'\r\n'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析数据"><a href="#解析数据" class="headerlink" title="解析数据"></a>解析数据</h3><h4 id="Frame（帧）"><a href="#Frame（帧）" class="headerlink" title="Frame（帧）"></a>Frame（帧）</h4><p>WebSocket 传输的数据都是以 Frame（帧）的形式实现的，就像 TCP/UDP 协议中的报文段 Segment。下面就是一个 Frame：（以 bit 为单位表示）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">  1               2               3               4</span></span><br><span class="line"><span class="comment">  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment"> +-+-+-+-+-------+-+-------------+-------------------------------+</span></span><br><span class="line"><span class="comment"> |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span></span><br><span class="line"><span class="comment"> |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span></span><br><span class="line"><span class="comment"> |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span></span><br><span class="line"><span class="comment"> | |1|2|3|       |K|             |                               |</span></span><br><span class="line"><span class="comment"> +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span></span><br><span class="line"><span class="comment"> |     Extended payload length continued, if payload len == 127  |</span></span><br><span class="line"><span class="comment"> + - - - - - - - - - - - - - - - +-------------------------------+</span></span><br><span class="line"><span class="comment"> |                               |Masking-key, if MASK set to 1  |</span></span><br><span class="line"><span class="comment"> +-------------------------------+-------------------------------+</span></span><br><span class="line"><span class="comment"> | Masking-key (continued)       |          Payload Data         |</span></span><br><span class="line"><span class="comment"> +-------------------------------- - - - - - - - - - - - - - - - +</span></span><br><span class="line"><span class="comment"> :                     Payload Data continued ...                :</span></span><br><span class="line"><span class="comment"> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span></span><br><span class="line"><span class="comment"> |                     Payload Data continued ...                |</span></span><br><span class="line"><span class="comment"> +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="按照-RFC-中的描述："><a href="#按照-RFC-中的描述：" class="headerlink" title="按照 RFC 中的描述："></a>按照 RFC 中的描述：</h5><ul><li>FIN： 1 bit， 0 表示还有后续帧，1 表示最后一帧</li><li>RSV1、2、3： 没个 1 bit，除非一个扩展经过协商赋予了非零值以某种含义，否则必须为 0，如果没有定义非零值，并且收到了非零的 RSV，则 websocket 链接会失败</li><li>Opcode： 4 bit，如果收到了未知的 opcode，最后会断开链接, 这四位的值组合结果的含义分别如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0x0 :</span> <span class="string">代表连续的帧</span></span><br><span class="line"><span class="attr">0x1 :</span> <span class="string">text帧</span></span><br><span class="line"><span class="number">0x2</span> <span class="string">：</span> <span class="string">binary帧</span></span><br><span class="line"><span class="number">0x3</span><span class="number">-0x7</span> <span class="string">：</span> <span class="string">为非控制帧而预留的</span></span><br><span class="line"><span class="number">0x8</span> <span class="string">：</span> <span class="string">关闭握手帧</span></span><br><span class="line"><span class="number">0x9</span> <span class="string">：</span> <span class="string">ping帧</span></span><br><span class="line"><span class="attr">0xA :</span> <span class="string">pong</span> <span class="string">帧</span></span><br><span class="line"><span class="number">0xB</span><span class="number">-0xF</span> <span class="string">：</span> <span class="string">为非控制帧而预留的</span></span><br></pre></td></tr></table></figure><ul><li>Mask： 1 bit，0 表示数据没有添加掩码，1 表示数据被添加了掩码，如果置 1， “Masking-key”就会被赋值，所有从客户端发往服务器的帧都会被置 1</li><li>Payload length： 7 bit | 7+16 bit | 7+64 bit，“payload data” 的长度如果在 0~125 bytes 范围内，它就是“payload length”，如果是 126 bytes， 紧随其后的被表示为 16 bits 的 2 bytes 无符号整型就是“payload length”，如果是 127 bytes， 紧随其后的被表示为 64 bits 的 8 bytes 无符号整型就是“payload length”</li><li>Masking-key： 0 or 4 bytes，所有从客户端发送到服务器的帧都包含一个 32 bits 的掩码（如果“mask bit”被设置成 1），否则为 0 bit。一旦掩码被设置，所有接收到的 payload data 都必须与该值以一种算法做异或运算来获取真实值。</li><li>Payload data: n bytes，数据内容</li></ul><h4 id="读取数据帧"><a href="#读取数据帧" class="headerlink" title="读取数据帧"></a>读取数据帧</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomReadSocket</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> MAGIC_STRING = <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(req, socket, head) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="comment">// 保存上下文信息</span></span><br><span class="line">    <span class="keyword">this</span>.req = req</span><br><span class="line">    <span class="keyword">this</span>.socket = socket</span><br><span class="line">    <span class="keyword">this</span>.head = head</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部状态</span></span><br><span class="line">    <span class="keyword">this</span>.dataType = <span class="string">''</span></span><br><span class="line">    <span class="keyword">this</span>.resHeaders = <span class="keyword">this</span>.buildHeaders(req.headers[<span class="string">'sec-websocket-key'</span>])</span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="keyword">this</span>.socket.on(<span class="string">'data'</span>, <span class="keyword">this</span>.handleData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应给客户端</span></span><br><span class="line">    <span class="keyword">this</span>.socket.write(<span class="keyword">this</span>.resHeaders)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建响应头</span></span><br><span class="line">  buildHeaders(secWebsocketKey) &#123;</span><br><span class="line">    <span class="comment">// 计算返回的key</span></span><br><span class="line">    <span class="keyword">const</span> resKey = crypto</span><br><span class="line">      .createHash(<span class="string">'sha1'</span>)</span><br><span class="line">      .update(secWebsocketKey + CustomReadSocket.MAGIC_STRING)</span><br><span class="line">      .digest(<span class="string">'base64'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造响应头</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="string">'HTTP/1.1 101 Switching Protocols'</span>,</span><br><span class="line">      <span class="string">'Upgrade: websocket'</span>,</span><br><span class="line">      <span class="string">'Connection: Upgrade'</span>,</span><br><span class="line">      <span class="string">'Sec-WebSocket-Accept: '</span> + resKey,</span><br><span class="line">    ]</span><br><span class="line">      .concat(<span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line">      .join(<span class="string">'\r\n'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理收到的数据</span></span><br><span class="line">  handleData = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> type = <span class="keyword">this</span>.getFrameType(data[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">if</span> (type &amp;&amp; type !== <span class="string">'continue'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataType = type</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (type === <span class="string">'continue'</span> || type === <span class="string">'text'</span> || type === <span class="string">'binary'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maskLen = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMask(data[<span class="number">1</span>])) &#123;</span><br><span class="line">          maskLen = <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> [start, len] = <span class="keyword">this</span>.getFrameDataLength(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.getDataFromFrame(</span><br><span class="line">          data.slice(start + maskLen),</span><br><span class="line">          data.slice(start, start + maskLen),</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.isLastFrame(data[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">this</span>.handleAllType(<span class="keyword">this</span>.dataType)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前帧类型</span></span><br><span class="line">  getFrameType(byte) &#123;</span><br><span class="line">    <span class="keyword">const</span> realType = byte &amp; <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">if</span> (!realType) &#123;</span><br><span class="line">      <span class="comment">// 代表连续的帧</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'continue'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realType === <span class="number">0x01</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'text'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realType === <span class="number">0x09</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'ping'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realType === <span class="number">0x0a</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'pong'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realType === <span class="number">0x02</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'binary'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realType === <span class="number">0x08</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'close'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理所有帧类型</span></span><br><span class="line">  handleAllType(type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'continue'</span>: &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'continue'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'text'</span>: &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'message'</span>, <span class="keyword">this</span>.buffer.toString())</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'binary'</span>: &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'message'</span>, <span class="keyword">this</span>.buffer)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'close'</span>: &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'close'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ping'</span>: &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'ping'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'pong'</span>: &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'pong'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'others'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放 buffer 和重置数据类型</span></span><br><span class="line">    <span class="keyword">this</span>.buffer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.dataType = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是最后一个帧</span></span><br><span class="line">  isLastFrame(byte) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(byte &amp; <span class="number">0x80</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提取帧的长度</span></span><br><span class="line">  getFrameDataLength(buffer) &#123;</span><br><span class="line">    <span class="comment">// 第二个字节的底 7 位</span></span><br><span class="line">    <span class="keyword">const</span> firtLen = buffer[<span class="number">1</span>] &amp; <span class="number">0x7f</span></span><br><span class="line">    <span class="keyword">if</span> (firtLen &lt; <span class="number">125</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="number">2</span>, firtLen]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firtLen === <span class="number">126</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> len = buffer.readUInt16BE(<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> [<span class="number">4</span>, len]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> len = buffer.readUInt64BE(<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> [<span class="number">10</span>, len]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否有掩码</span></span><br><span class="line">  hasMask(byte) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!(<span class="number">0x80</span> &amp; byte)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从帧里提取数据</span></span><br><span class="line">  getDataFromFrame(buffer, maskBuffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer &amp;&amp; buffer.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> len = buffer.length</span><br><span class="line">      <span class="keyword">if</span> (maskBuffer &amp;&amp; maskBuffer.length === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">          buffer[i] = buffer[i] ^ maskBuffer[i % <span class="number">4</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.buffer = <span class="keyword">this</span>.buffer ? Buffer.concat([<span class="keyword">this</span>.buffer, buffer]) : buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入数据帧"><a href="#写入数据帧" class="headerlink" title="写入数据帧"></a>写入数据帧</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomWebsocket</span> <span class="keyword">extends</span> <span class="title">CustomReadSocket</span> </span>&#123;</span><br><span class="line">  timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">constructor</span>(req, socket, head, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(req, socket, head)</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timeout()</span><br><span class="line">    <span class="keyword">this</span>.socket.on(<span class="string">'data'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.timeout()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(message) &#123;</span><br><span class="line">    <span class="keyword">const</span> buffer = Buffer.from(message)</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">this</span>.buildDataFrameList(<span class="string">'text'</span>, buffer)</span><br><span class="line">    list.forEach(<span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.socket.write(frame)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.timeout()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ping() &#123;</span><br><span class="line">    <span class="keyword">const</span> frame = <span class="keyword">this</span>.buildFrame(<span class="string">'ping'</span>)</span><br><span class="line">    <span class="keyword">this</span>.socket.write(frame)</span><br><span class="line">    <span class="keyword">this</span>.timeout()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pong() &#123;</span><br><span class="line">    <span class="keyword">const</span> frame = <span class="keyword">this</span>.buildFrame(<span class="string">'pong'</span>)</span><br><span class="line">    <span class="keyword">this</span>.socket.write(frame)</span><br><span class="line">    <span class="keyword">this</span>.timeout()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close() &#123;</span><br><span class="line">    <span class="keyword">const</span> frame = <span class="keyword">this</span>.buildFrame(<span class="string">'close'</span>)</span><br><span class="line">    <span class="keyword">this</span>.socket.write(frame)</span><br><span class="line">    <span class="keyword">this</span>.socket.end()</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.socket.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timeout() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; timeout = <span class="number">10000</span> &#125; = <span class="keyword">this</span>.options || &#123;&#125;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timer)</span><br><span class="line">    <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.ping()</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildDataFrameList(type, buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> bufferList = []</span><br><span class="line">    <span class="keyword">let</span> tempBuffer = buffer</span><br><span class="line">    <span class="keyword">while</span> (tempBuffer.length) &#123;</span><br><span class="line">      bufferList.push(tempBuffer.slice(<span class="number">0</span>, <span class="keyword">this</span>.MAX_FRAME_SIZE))</span><br><span class="line">      tempBuffer = tempBuffer.slice(<span class="keyword">this</span>.MAX_FRAME_SIZE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> len = bufferList.length</span><br><span class="line">    <span class="keyword">return</span> bufferList.map(<span class="function">(<span class="params">buf, index</span>) =&gt;</span></span><br><span class="line">      <span class="keyword">this</span>.buildFrame(index ? <span class="string">'continue'</span> : type, len === index + <span class="number">1</span>, buf),</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildFrame(dataType, isLast = <span class="literal">true</span>, buffer = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> firstByte = isLast ? <span class="number">0x80</span> : <span class="number">0x00</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="string">`<span class="subst">$&#123;dataType || <span class="string">''</span>&#125;</span>`</span>.toLowerCase()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'continue'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x00</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'text'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x01</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'binary'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x02</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'close'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x08</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ping'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x09</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'pong'</span>: &#123;</span><br><span class="line">        firstByte = firstByte | <span class="number">0x0a</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'others'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> secondByte = <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer &amp;&amp; buffer.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> lenByteList = []</span><br><span class="line">      <span class="keyword">const</span> len = buffer.length</span><br><span class="line">      <span class="keyword">if</span> (len &lt;= <span class="number">125</span>) &#123;</span><br><span class="line">        secondByte = secondByte | len</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt;= <span class="number">126</span> &amp;&amp; len &lt; <span class="number">65536</span>) &#123;</span><br><span class="line">        secondByte = secondByte | <span class="number">0x7e</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">          lenByteList.push(<span class="number">0xff</span> &amp; (len &gt;&gt; (i * <span class="number">8</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        secondByte = secondByte | <span class="number">0x7f</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">          lenByteList.push(<span class="number">0xff</span> &amp; (len &gt;&gt; (i * <span class="number">8</span>)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lenByteList.reverse()</span><br><span class="line">      <span class="keyword">const</span> prefixBuffer = Buffer.from([firstByte, secondByte, ...lenByteList])</span><br><span class="line">      <span class="keyword">return</span> Buffer.concat([prefixBuffer, buffer])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Buffer.from([firstByte, secondByte])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank" rel="noopener">学习 WebSocket 协议—从顶层到底层的实现原理（修订版）</a></li><li><a href="https://segmentfault.com/a/1190000016467409" target="_blank" rel="noopener">Node.js - 200 多行代码实现 Websocket 协议</a></li><li><a href="https://segmentfault.com/a/1190000012709475" target="_blank" rel="noopener">WebSocket：5 分钟从入门到精通</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers" target="_blank" rel="noopener">编写 WebSocket 服务器</a></li><li><a href="https://github.com/JackXuyi/web-exercise/blob/master/handwriting/socketServer.js" target="_blank" rel="noopener">本文涉及到的页面源代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;建立链接&quot;&gt;&lt;a href=&quot;#建立链接&quot; class=&quot;headerlink&quot; title=&quot;建立链接&quot;&gt;&lt;/a&gt;建立链接&lt;/h3&gt;&lt;p&gt;若要实现 WebSocket 协议，首先需要浏览器主动发起一个 HTTP 请求。&lt;/p&gt;
&lt;p&gt;这个请求头包含“Upgrad
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>记一次项目打包优化</title>
    <link href="http://yoursite.com/2020/12/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/12/23/记一次项目打包优化/</id>
    <published>2020-12-22T19:19:21.000Z</published>
    <updated>2021-04-04T15:05:16.567Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目功能越来复杂，打包发布的速度越来越慢，严重影响了开发速度，所以决定优化下打包发布速度</p><h2 id="分析打包流程及耗时"><a href="#分析打包流程及耗时" class="headerlink" title="分析打包流程及耗时"></a>分析打包流程及耗时</h2><h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><ul><li>代码 clone 到打包服务器上</li><li>编译代码，项目采用 nextjs 进行服务端渲染，所以编译编译时分为两个部分，分别为构建服务端 js 和客户端 js，每次编译都要先安装项目依赖，再执行打包构建命令</li><li>构建 docker 容器，项目运行在 docker 容器中，每次打包发布都是构建一个新的容器去替换对应环境的容器</li><li>部署静态资源，把客户端对应的 js 推送到 CDN 上</li><li>替换容器，用之前构建的容器去替换当前环境的容器</li></ul><h3 id="耗时分析"><a href="#耗时分析" class="headerlink" title="耗时分析"></a>耗时分析</h3><ul><li>clone 代码速度由网络和项目大小决定（网络无法控制，源代码不大，优化效果不明显）—— 通常在 10 秒左右</li><li>采用 webpack 进行编译，可以通过插件进行构建优化 —— 通常在 2.5 分钟左右</li><li>构建 docker 容器时会把 node_modules 下的依赖按照生产模式的方式放入容器中 —— 通常在 4.5 分钟左右</li><li>静态资源的上传由上传资源大小及网络决定，上传由基础组控制 —— 2 分钟左右</li><li>替换容器由集群控制，业务方无法控制 —— 通常在 1 分左右</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>通过上面的分析发现，制作 docker 容器和 打包过程最耗费时间，且这两块也在业务方控制之中，所以优化从这两方面着手</p><h3 id="docker-容器优化"><a href="#docker-容器优化" class="headerlink" title="docker 容器优化"></a>docker 容器优化</h3><p>通过查看打包日志发现制作 docker 容器时发现制作容器时发送的上下文达 1G 多，对比其它项目明显偏大</p><h4 id="优化方向分析"><a href="#优化方向分析" class="headerlink" title="优化方向分析"></a>优化方向分析</h4><ul><li>发送的上下文是在生产模式下安装的依赖，即只会安装 <code>dependencies</code> 下的依赖 —— 考虑把所有非服务端必须的依赖安装到 <code>devDependencies</code> 中以减小上下文大小</li><li>由于需要 SEO 优化，优化不能减少服务端渲染时的页面内容 —— 只能优化对页面内容没有影响但是需要客户端交互及样式操作相关的库</li></ul><h4 id="优化操作"><a href="#优化操作" class="headerlink" title="优化操作"></a>优化操作</h4><ul><li>通过 webpack 插件提取项目中使用的依赖，结合 package.json 的配置，筛选出项目中无用的依赖</li><li>筛选出 <code>dependencies</code> 中的依赖是否可以只在客户端渲染时引入，例如 <code>react-copy-to-clipboard</code> 只会在客户端执行复制操作就可以放入 <code>devDependencies</code> 中以便只在客户端引入</li></ul><h4 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h4><p>构建 docker 容器的时间从优化前的 4.5 分钟左右下降到 2.5 分钟左右，优化了 50%</p><h3 id="webpack-打包优化"><a href="#webpack-打包优化" class="headerlink" title="webpack 打包优化"></a>webpack 打包优化</h3><p>此项目是基于 webpack 4.x 进行打包的，可以通过插件和 webpack 配置及 loader 的形式进行打包优化</p><h4 id="webpack-4-使用-v8-引擎带来的优化"><a href="#webpack-4-使用-v8-引擎带来的优化" class="headerlink" title="webpack 4 使用 v8 引擎带来的优化"></a>webpack 4 使用 v8 引擎带来的优化</h4><ul><li>for of 替代 forEach</li><li>Map 和 Set 替代 Object</li><li>includes 替代 indexOf()</li><li>默认使用更快的 md4 hash 算法 替代 md5 算法，md4 较 md5 速度更快</li><li>webpack AST 可以直接从 loader 传递给 AST，从而减少解析时间</li><li>使用字符串方法替代正则表达式</li></ul><h4 id="优化方向分析-1"><a href="#优化方向分析-1" class="headerlink" title="优化方向分析"></a>优化方向分析</h4><p>通过 <a href="https://www.npmjs.com/package/speed-measure-webpack-plugin" target="_blank" rel="noopener">speed-measure-webpack-plugin</a> 插件进行打包耗时分析</p><ul><li>通过配置 <code>exclude / include</code> 和忽略第三方包指定目录及通过 externals 缩小打包文件范围</li><li>多进程并行打包和代码压缩</li><li>缓存编译结果</li><li>babel 配置的优化</li></ul><h4 id="优化操作-1"><a href="#优化操作-1" class="headerlink" title="优化操作"></a>优化操作</h4><p>通过研究框架 webpack 配置发现项目已经引入 <code>cache-loader</code>、<code>thread-loader</code> 等 <code>loader</code> 和插件及配置优化代码打包速度，所以未做 <code>webpack</code> 打包优化</p><ul><li>引入 <code>speed-measure-webpack-plugin</code> 查看打包耗时</li></ul><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><ul><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">docker</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目功能越来复杂，打包发布的速度越来越慢，严重影响了开发速度，所以决定优化下打包发布速度&lt;/p&gt;
&lt;h2 id=&quot;分析打包流程及耗时&quot;&gt;&lt;a href=&quot;#分析打包流程及耗时&quot; class=&quot;headerlink&quot; title=&quot;分析打包流程及耗时&quot;&gt;&lt;/a&gt;分析打包流
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="other" scheme="http://yoursite.com/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>ts之type、interface和class区别</title>
    <link href="http://yoursite.com/2020/12/14/ts%E4%B9%8Btype%E3%80%81interface%E5%92%8Cclass%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/12/14/ts之type、interface和class区别/</id>
    <published>2020-12-13T22:04:08.000Z</published>
    <updated>2020-12-22T11:17:35.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases" target="_blank" rel="noopener">任意类型的别名</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.</span><br><span class="line">A type alias is exactly that - a name for any type.</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test = <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error: 标识符“test”重复。</span></span><br><span class="line"><span class="comment">// type test = string</span></span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>任意类型的别名（包含基本类型）</li><li>只可以定义一次（多次定义报 ’标识符“test”重复‘ 错误）</li></ul><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p><a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener">接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  size?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  penWidth: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br><span class="line">square.penWidth = <span class="number">5.0</span></span><br><span class="line">square.size = <span class="number">100</span></span><br></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类是“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeScript offers full support for the class keyword introduced in ES2015. As with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullName = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error: Unauthorized update of employee!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  alert(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="abstract-class"><a href="#abstract-class" class="headerlink" title="abstract class"></a>abstract class</h3><p><a href="https://www.tslang.cn/docs/handbook/classes.html" target="_blank" rel="noopener">抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</a></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName()</span><br><span class="line">department.printMeeting()</span><br><span class="line">department.generateReports() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。</li><li>类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）。</li><li>接口只能用来声明对象，而不能重新命名基本数据类型。</li><li>接口名称将始终以原始形式出现在错误消息中，当按名称使用时才显示。</li><li>接口可以进行声明合并</li><li>抽象类和接口一样不可以被实例化，但是抽象类可以包含部分属性方法的实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;type&quot;&gt;&lt;a href=&quot;#type&quot; class=&quot;headerlink&quot; title=&quot;type&quot;&gt;&lt;/a&gt;type&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/2/everyd
      
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>for...in和for...of的区别</title>
    <link href="http://yoursite.com/2020/11/22/for-in%E5%92%8Cfor-of%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/11/22/for-in和for-of的区别/</id>
    <published>2020-11-21T17:09:16.000Z</published>
    <updated>2020-11-21T10:25:50.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h3><p>遍历器（Iterator）一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><h4 id="Iterator-的作用"><a href="#Iterator-的作用" class="headerlink" title="Iterator 的作用"></a>Iterator 的作用</h4><ul><li>为各种数据结构，提供一个统一的、简便的访问接口。</li><li>使得数据结构的成员能够按某种次序排列。</li><li>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。</li></ul><h4 id="Iterator-的遍历"><a href="#Iterator-的遍历" class="headerlink" title="Iterator 的遍历"></a>Iterator 的遍历</h4><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</li></ol><h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。</p><h5 id="ES6-原生具备-Iterator-接口的数据结构"><a href="#ES6-原生具备-Iterator-接口的数据结构" class="headerlink" title="ES6 原生具备 Iterator 接口的数据结构"></a>ES6 原生具备 Iterator 接口的数据结构</h5><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><h4 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h4><ul><li>解构赋值</li><li>扩展运算符</li><li>yield*</li><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()</li><li>Promise.all()</li><li>Promise.race()</li></ul><h4 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h4><p>遍历器对象除了具有 next()方法，还可以具有 return()方法和 throw()方法。</p><ul><li>如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句），就会调用 return()方法。</li><li>throw()方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</li></ul><h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a>for…in 和 for…of 的区别</h3><ul><li>对于普通的对象，for…in 循环可以遍历键名，for…of 循环会报错。</li></ul><h4 id="for…in-遍历数组的缺点"><a href="#for…in-遍历数组的缺点" class="headerlink" title="for…in 遍历数组的缺点"></a>for…in 遍历数组的缺点</h4><ul><li>数组的键名是数字，但是 for…in 循环是以字符串作为键名“0”、“1”、“2”等等。</li><li>for…in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，for…in 循环会以任意顺序遍历键名。</li></ul><h4 id="for…of-遍历数组的优点"><a href="#for…of-遍历数组的优点" class="headerlink" title="for…of 遍历数组的优点"></a>for…of 遍历数组的优点</h4><ul><li>有着同 for…in 一样的简洁语法，但是没有 for…in 那些缺点</li><li>不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Iterator（遍历器）的概念&quot;&gt;&lt;a href=&quot;#Iterator（遍历器）的概念&quot; class=&quot;headerlink&quot; title=&quot;Iterator（遍历器）的概念&quot;&gt;&lt;/a&gt;Iterator（遍历器）的概念&lt;/h3&gt;&lt;p&gt;遍历器（Iterator）一
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>异步任务按顺序分组执行</title>
    <link href="http://yoursite.com/2020/10/19/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%88%86%E7%BB%84%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2020/10/19/异步任务按顺序分组执行/</id>
    <published>2020-10-18T16:39:31.000Z</published>
    <updated>2020-10-18T08:53:13.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个异步请求列表需要按照顺序分多次执行</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>任务可以放入一个队列中，每次从队列中获取若干任务异步执行</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一次执行的任务放在 Promise.all 中执行，但是如果执行任务中有一个任务花费时间比较长，其它任务消耗时间短就浪费了大量时间，所以采用计数的方式判断是否可以把任务加入任务队列</p><h4 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h4><ol><li>构建任务队列</li><li>需要执行的任务放入队列</li><li>执行任务，判断是否有任务可以执行，若有任务可以执行，则正在执行的任务队列加一</li><li>任务执行完毕之后，再回到第 3 部，直至待执行任务队列和当前执行的任务为空时退出程序</li></ol><h4 id="具体-js-代码如下"><a href="#具体-js-代码如下" class="headerlink" title="具体 js 代码如下"></a>具体 js 代码如下</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(maxTask) &#123;</span><br><span class="line">    <span class="keyword">this</span>.maxTask = maxTask</span><br><span class="line">    <span class="keyword">this</span>.runningTask = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.taskQueue = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(task)) &#123;</span><br><span class="line">      task.forEach(<span class="function">(<span class="params">t</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskQueue.push(t)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.taskQueue.push(task)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> runTask(task) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.runningTask++</span><br><span class="line">      <span class="keyword">await</span> task()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">      <span class="keyword">this</span>.runningTask--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.canRunTask()) &#123;</span><br><span class="line">      <span class="keyword">const</span> task = <span class="keyword">this</span>.taskQueue.shift()</span><br><span class="line">      <span class="keyword">this</span>.runTask(task)</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canRunTask() &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.isEmpty() &amp;&amp; <span class="keyword">this</span>.runningTask &lt; <span class="keyword">this</span>.maxTask</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.taskQueue.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> taskQueue = <span class="keyword">new</span> Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeList = [<span class="number">100</span>, <span class="number">300</span>, <span class="number">500</span>, <span class="number">900</span>, <span class="number">600</span>]</span><br><span class="line"><span class="keyword">const</span> taskList = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>).fill(<span class="number">0</span>).map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> time = index % timeList.length</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'task '</span>, index, <span class="string">'time '</span>, timeList[time], <span class="string">'start'</span>)</span><br><span class="line">      <span class="keyword">const</span> timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'task '</span>, index, <span class="string">'time '</span>, timeList[time], <span class="string">'finished'</span>)</span><br><span class="line">        <span class="keyword">if</span> (index % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          reject(<span class="string">'error'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, timeList[time])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">taskQueue.push(taskList)</span><br></pre></td></tr></table></figure><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><ul><li><a href="https://github.com/JackXuyi/web-exercise/blob/master/algorithm/queue.js" target="_blank" rel="noopener">源码参考</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;有一个异步请求列表需要按照顺序分多次执行&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/solution/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="http://yoursite.com/2020/09/23/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/09/23/三数之和/</id>
    <published>2020-09-22T20:52:19.000Z</published>
    <updated>2020-09-22T13:05:11.776Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">leetcode 算法题</a></p><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>三层循环遍历数组把符合条件的数据放入数组之中，然后再去重，时间复杂度 n<em>n</em>n 再加去重时间</p><h3 id="优化暴力求解"><a href="#优化暴力求解" class="headerlink" title="优化暴力求解"></a>优化暴力求解</h3><p>数组排序，然后遍历数组，把数据放入对象中去重，避免最后的去重操作，时间复杂度 n<em>n</em>n</p><h3 id="双指针方法"><a href="#双指针方法" class="headerlink" title="双指针方法"></a>双指针方法</h3><p>数组进行排序，然后外层循环固定一个数，内层使用两个指针分别指向数组的左右两边，如果三数之和小于 0 则把左边指针右移，若果三数之和大于 0 则把右边指针左移，等于 0 时判断数组是否已经存在结果数组中，若存在则跳过，不存在放入数组并在 map 中标记</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sortNums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">const</span> len = sortNums.length</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> right = len - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sortNums[i] + sortNums[left] + sortNums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        right = right - <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortNums[i] + sortNums[left] + sortNums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        left = left + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortNums[i] + sortNums[left] + sortNums[right] === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj[<span class="string">`<span class="subst">$&#123;sortNums[i]&#125;</span>,<span class="subst">$&#123;sortNums[left]&#125;</span>,<span class="subst">$&#123;sortNums[right]&#125;</span>`</span>]) &#123;</span><br><span class="line">          result.push([sortNums[i], sortNums[left], sortNums[right]])</span><br><span class="line">          obj[<span class="string">`<span class="subst">$&#123;sortNums[i]&#125;</span>,<span class="subst">$&#123;sortNums[left]&#125;</span>,<span class="subst">$&#123;sortNums[right]&#125;</span>`</span>] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        left = left + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode 算法题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;暴力求解&quot;&gt;&lt;a href=&quot;#暴力求解&quot; class=
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/solution/"/>
    
  </entry>
  
</feed>
